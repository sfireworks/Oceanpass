Oceanpass设计文档

# 项目背景
这个项目的需求主要来自于两个方面：
* 不同云服务商之间、同一云服务商的不同地域之间的对象存储系统的数据没有常用的流转方案，用户需要手动接入多个对象存储，自己实现繁琐的流转；
* 不同云服务商的对象存储虽然大都遵循AWS S3的协议标准，但是会有一些细微差异，用户接入使用时需要使用不同的SDK；
以上两点给用户大规模使用对象存储带来了阻碍，因此我们提出了oceanpass，提供统一的接口，隐藏不同云服务商之间的协议差异，并提供用户流转数据的功能。

# 方案设计
## 接入服务形态：Thin vs Fat
如何选择接入服务的形态。与文件存储的接入不同，对象存储由于云厂商提供SDK，我们可以直接封装SDK来实现接入的无感。
然而封装有两种思路：

- Thin client: 一类是把封装SDK当成是包一层函数(client library)，用户在调用的时候直接调用library，实际内部还是经过一些逻辑实际调用的原始的SDK，由云厂商内部的SDK实现与后台对象存储服务端的沟通

- Fat client: 一类是把客户端做成较函数更重的http服务，通过http请求与原始客户沟通，需要单独部署。需要注意的是因为大部分原始SDK在对象存储上都是基于S3协议的，代码结构可以共用的部分非常多。由于它在部署上是网络拓扑上新多出的一个节点，需要单独考虑为其分配网络、内存、CPU资源。此处由于对象存储的封装内部并没有太多自有逻辑，因此主要需要考虑的资源类型是网络。

为了实现后续的缓存以及一些扩展功能，我们选择了Fat Client。
